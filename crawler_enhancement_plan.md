# çˆ¬è™«ç³»ç»Ÿå¢å¼ºæ–¹æ¡ˆ

## æ ¸å¿ƒé—®é¢˜åˆ†æ

### å½“å‰é—®é¢˜
1. âŒ çˆ¬è™«å¤±è´¥æ— æ„ŸçŸ¥ï¼ˆè¿è¡Œäº†ä½†æ²¡æ•°æ®ä¹Ÿä¸çŸ¥é“ï¼‰
2. âŒ å¤±è´¥ä¸é‡è¯•ï¼ˆç½‘ç»œæŠ–åŠ¨å°±å¤±è´¥ï¼‰
3. âŒ æ— ç›‘æ§å‘Šè­¦ï¼ˆæ·±å¤œå¤±è´¥æ— äººçŸ¥ï¼‰
4. âŒ æ•°æ®æœªæŒä¹…åŒ–ï¼ˆå†™å…¥å¤±è´¥å°±ä¸¢å¤±ï¼‰
5. âŒ æ— æ‰§è¡Œæ—¥å¿—ï¼ˆä¸çŸ¥é“ä½•æ—¶è¿è¡Œè¿‡ï¼‰

### è§£å†³æ–¹æ¡ˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         APScheduler (è°ƒåº¦å™¨)                     â”‚
â”‚  - å®šæ—¶è§¦å‘                                      â”‚
â”‚  - Cronè¡¨è¾¾å¼                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         çˆ¬è™«ä»»åŠ¡åŒ…è£…å™¨ (Wrapper)                 â”‚
â”‚  - é”™è¯¯æ•è·                                      â”‚
â”‚  - é‡è¯•æœºåˆ¶ï¼ˆæœ€å¤š3æ¬¡ï¼‰                           â”‚
â”‚  - è¶…æ—¶æ§åˆ¶                                      â”‚
â”‚  - æ•°æ®éªŒè¯                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚
        â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ‰§è¡Œçˆ¬è™«    â”‚    â”‚  è®°å½•æ—¥å¿—    â”‚
â”‚  ä¿å­˜æ•°æ®    â”‚    â”‚  å‘é€å‘Šè­¦    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PostgreSQL    â”‚
        â”‚  - ä»»åŠ¡è®°å½•è¡¨  â”‚
        â”‚  - æ•°æ®è¡¨      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Day 1-2: ä»»åŠ¡è®°å½•ç³»ç»Ÿ

### 1. åˆ›å»ºä»»åŠ¡è®°å½•è¡¨
```sql
-- çˆ¬è™«æ‰§è¡Œè®°å½•è¡¨
CREATE TABLE crawler_task_logs (
    id SERIAL PRIMARY KEY,
    task_name VARCHAR(100) NOT NULL,
    spider_name VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,  -- running, success, failed, retrying
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,
    duration_seconds INTEGER,
    records_count INTEGER DEFAULT 0,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);

-- ç´¢å¼•
CREATE INDEX idx_task_name_time ON crawler_task_logs(task_name, start_time DESC);
CREATE INDEX idx_status ON crawler_task_logs(status);
```

### 2. çˆ¬è™«åŒ…è£…å™¨
```python
# app/crawlers/base_crawler.py
from typing import Callable, Any
from datetime import datetime
import traceback
import time
from functools import wraps
from app.models.database import SessionLocal
from app.models.models import CrawlerTaskLog

class CrawlerWrapper:
    """çˆ¬è™«ä»»åŠ¡åŒ…è£…å™¨ - æä¾›é‡è¯•ã€æ—¥å¿—ã€å‘Šè­¦åŠŸèƒ½"""

    def __init__(
        self,
        task_name: str,
        spider_name: str,
        max_retries: int = 3,
        retry_delay: int = 60,  # é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰
        timeout: int = 300,     # è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
        notify_on_failure: bool = True
    ):
        self.task_name = task_name
        self.spider_name = spider_name
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.timeout = timeout
        self.notify_on_failure = notify_on_failure

    def __call__(self, func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            task_log = self._create_task_log()
            retry_count = 0

            while retry_count <= self.max_retries:
                try:
                    # æ‰§è¡Œçˆ¬è™«
                    start_time = time.time()
                    result = func(*args, **kwargs)
                    duration = int(time.time() - start_time)

                    # éªŒè¯ç»“æœ
                    if not self._validate_result(result):
                        raise ValueError("çˆ¬å–æ•°æ®ä¸ºç©ºæˆ–æ— æ•ˆ")

                    # è®°å½•æˆåŠŸ
                    self._update_task_log(
                        task_log,
                        status='success',
                        duration=duration,
                        records_count=len(result) if isinstance(result, list) else 1,
                        retry_count=retry_count
                    )

                    # æˆåŠŸåå‘é€é€šçŸ¥ï¼ˆå¦‚æœæ˜¯é‡è¯•æˆåŠŸï¼‰
                    if retry_count > 0:
                        self._send_notification(
                            f"âœ… {self.task_name} é‡è¯•æˆåŠŸ",
                            f"é‡è¯•{retry_count}æ¬¡åæˆåŠŸï¼Œè·å–{len(result) if isinstance(result, list) else 1}æ¡æ•°æ®"
                        )

                    return result

                except Exception as e:
                    retry_count += 1
                    error_msg = f"{str(e)}\n{traceback.format_exc()}"

                    if retry_count <= self.max_retries:
                        # è¿˜æœ‰é‡è¯•æœºä¼š
                        self._update_task_log(
                            task_log,
                            status='retrying',
                            error_message=error_msg,
                            retry_count=retry_count
                        )

                        print(f"âš ï¸ {self.task_name} å¤±è´¥ï¼Œ{self.retry_delay}ç§’åé‡è¯•ï¼ˆ{retry_count}/{self.max_retries}ï¼‰")
                        time.sleep(self.retry_delay)
                    else:
                        # æœ€ç»ˆå¤±è´¥
                        duration = int(time.time() - start_time)
                        self._update_task_log(
                            task_log,
                            status='failed',
                            duration=duration,
                            error_message=error_msg,
                            retry_count=retry_count - 1
                        )

                        # å‘é€å¤±è´¥å‘Šè­¦
                        if self.notify_on_failure:
                            self._send_notification(
                                f"âŒ {self.task_name} æœ€ç»ˆå¤±è´¥",
                                f"é‡è¯•{self.max_retries}æ¬¡åä»å¤±è´¥\né”™è¯¯: {str(e)}"
                            )

                        raise

        return wrapper

    def _create_task_log(self) -> int:
        """åˆ›å»ºä»»åŠ¡è®°å½•"""
        db = SessionLocal()
        try:
            log = CrawlerTaskLog(
                task_name=self.task_name,
                spider_name=self.spider_name,
                status='running',
                start_time=datetime.now()
            )
            db.add(log)
            db.commit()
            db.refresh(log)
            return log.id
        finally:
            db.close()

    def _update_task_log(
        self,
        task_id: int,
        status: str,
        duration: int = None,
        records_count: int = 0,
        error_message: str = None,
        retry_count: int = 0
    ):
        """æ›´æ–°ä»»åŠ¡è®°å½•"""
        db = SessionLocal()
        try:
            log = db.query(CrawlerTaskLog).filter_by(id=task_id).first()
            if log:
                log.status = status
                log.end_time = datetime.now()
                if duration:
                    log.duration_seconds = duration
                log.records_count = records_count
                log.error_message = error_message
                log.retry_count = retry_count
                db.commit()
        finally:
            db.close()

    def _validate_result(self, result: Any) -> bool:
        """éªŒè¯ç»“æœæœ‰æ•ˆæ€§"""
        if result is None:
            return False
        if isinstance(result, (list, dict)) and len(result) == 0:
            return False
        return True

    def _send_notification(self, title: str, content: str):
        """å‘é€é’‰é’‰/ä¼ä¸šå¾®ä¿¡é€šçŸ¥"""
        try:
            from app.services.notification import send_dingtalk_alert
            send_dingtalk_alert(title, content)
        except Exception as e:
            print(f"å‘é€é€šçŸ¥å¤±è´¥: {e}")
```

### 3. ä½¿ç”¨ç¤ºä¾‹
```python
# app/crawlers/zhihui_spider.py
from app.crawlers.base_crawler import CrawlerWrapper

@CrawlerWrapper(
    task_name="æ™ºæ±‡æœŸè®¯-å¤šç©ºå…¨æ™¯",
    spider_name="zhihui_spider",
    max_retries=3,
    retry_delay=60,
    timeout=300
)
def crawl_zhihui_sentiment():
    """çˆ¬å–æ™ºæ±‡æœŸè®¯æ•°æ®"""
    # ... åŸæœ‰çˆ¬è™«é€»è¾‘ ...
    return data  # è¿”å›æ•°æ®åˆ—è¡¨

# è°ƒåº¦å™¨ä¸­ä½¿ç”¨
scheduler.add_job(
    crawl_zhihui_sentiment,
    'cron',
    hour=20,
    minute=30,
    id='zhihui_sentiment'
)
```

## Day 3-4: å‘Šè­¦é€šçŸ¥ç³»ç»Ÿ

### 1. é’‰é’‰æœºå™¨äººé€šçŸ¥
```python
# app/services/notification.py
import requests
import hmac
import hashlib
import base64
import time
from urllib.parse import quote_plus
from config.settings import get_settings

settings = get_settings()

def send_dingtalk_alert(title: str, content: str, at_all: bool = False):
    """
    å‘é€é’‰é’‰æœºå™¨äººé€šçŸ¥

    é…ç½®æ­¥éª¤ï¼š
    1. é’‰é’‰ç¾¤ -> ç¾¤è®¾ç½® -> æ™ºèƒ½ç¾¤åŠ©æ‰‹ -> æ·»åŠ æœºå™¨äºº -> è‡ªå®šä¹‰
    2. å®‰å…¨è®¾ç½®ï¼šé€‰æ‹©"åŠ ç­¾"
    3. å¤åˆ¶Webhookå’Œå¯†é’¥åˆ° .env
    """
    webhook = settings.DINGTALK_WEBHOOK
    secret = settings.DINGTALK_SECRET

    if not webhook:
        print("âš ï¸ æœªé…ç½®é’‰é’‰Webhook")
        return

    # è®¡ç®—ç­¾å
    timestamp = str(round(time.time() * 1000))
    secret_enc = secret.encode('utf-8')
    string_to_sign = f'{timestamp}\n{secret}'
    string_to_sign_enc = string_to_sign.encode('utf-8')
    hmac_code = hmac.new(
        secret_enc,
        string_to_sign_enc,
        digestmod=hashlib.sha256
    ).digest()
    sign = quote_plus(base64.b64encode(hmac_code))

    # æ„å»ºURL
    url = f"{webhook}&timestamp={timestamp}&sign={sign}"

    # æ¶ˆæ¯å†…å®¹
    message = {
        "msgtype": "markdown",
        "markdown": {
            "title": title,
            "text": f"## {title}\n\n{content}\n\n> æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}"
        }
    }

    if at_all:
        message["at"] = {"isAtAll": True}

    # å‘é€
    try:
        resp = requests.post(url, json=message, timeout=5)
        if resp.status_code == 200:
            print(f"âœ… é’‰é’‰é€šçŸ¥å‘é€æˆåŠŸ: {title}")
        else:
            print(f"âŒ é’‰é’‰é€šçŸ¥å‘é€å¤±è´¥: {resp.text}")
    except Exception as e:
        print(f"âŒ é’‰é’‰é€šçŸ¥å¼‚å¸¸: {e}")


def send_daily_report():
    """æ¯æ—¥çˆ¬è™«æ‰§è¡ŒæŠ¥å‘Š"""
    from app.models.database import SessionLocal
    from app.models.models import CrawlerTaskLog
    from sqlalchemy import func
    from datetime import datetime, timedelta

    db = SessionLocal()
    try:
        # ç»Ÿè®¡ä»Šæ—¥ä»»åŠ¡
        today = datetime.now().date()
        stats = db.query(
            CrawlerTaskLog.status,
            func.count(CrawlerTaskLog.id).label('count')
        ).filter(
            func.date(CrawlerTaskLog.start_time) == today
        ).group_by(CrawlerTaskLog.status).all()

        total = sum(s.count for s in stats)
        success = next((s.count for s in stats if s.status == 'success'), 0)
        failed = next((s.count for s in stats if s.status == 'failed'), 0)

        success_rate = (success / total * 100) if total > 0 else 0

        content = f"""
### ğŸ“Š ä»Šæ—¥çˆ¬è™«æ‰§è¡Œæƒ…å†µ

- **æ€»ä»»åŠ¡æ•°**: {total}
- **æˆåŠŸ**: {success} âœ…
- **å¤±è´¥**: {failed} âŒ
- **æˆåŠŸç‡**: {success_rate:.1f}%

---

### æ˜ç»†
"""
        for stat in stats:
            emoji = "âœ…" if stat.status == "success" else "âŒ" if stat.status == "failed" else "âš ï¸"
            content += f"- {emoji} {stat.status}: {stat.count}æ¬¡\n"

        send_dingtalk_alert("æ¯æ—¥çˆ¬è™«æŠ¥å‘Š", content)

    finally:
        db.close()
```

### 2. ç¯å¢ƒå˜é‡é…ç½®
```python
# .env
DINGTALK_WEBHOOK=https://oapi.dingtalk.com/robot/send?access_token=xxxxx
DINGTALK_SECRET=SECxxxxxxxxxxxxx
```

## Day 5: ç›‘æ§é¢æ¿

### 1. çˆ¬è™«å¥åº·æ£€æŸ¥API
```python
# app/routers/admin.py
from fastapi import APIRouter, Depends
from sqlalchemy import func, desc
from app.models.database import get_db
from app.models.models import CrawlerTaskLog
from datetime import datetime, timedelta

router = APIRouter(prefix="/admin", tags=["ç®¡ç†"])

@router.get("/crawler/health")
async def crawler_health_check(db = Depends(get_db)):
    """çˆ¬è™«å¥åº·æ£€æŸ¥"""

    # æœ€è¿‘24å°æ—¶ä»»åŠ¡ç»Ÿè®¡
    since = datetime.now() - timedelta(hours=24)

    tasks = db.query(
        CrawlerTaskLog.task_name,
        CrawlerTaskLog.status,
        func.count(CrawlerTaskLog.id).label('count'),
        func.max(CrawlerTaskLog.start_time).label('last_run')
    ).filter(
        CrawlerTaskLog.start_time >= since
    ).group_by(
        CrawlerTaskLog.task_name,
        CrawlerTaskLog.status
    ).all()

    # æ±‡æ€»
    task_summary = {}
    for task in tasks:
        if task.task_name not in task_summary:
            task_summary[task.task_name] = {
                'success': 0,
                'failed': 0,
                'last_run': None
            }

        task_summary[task.task_name][task.status] = task.count
        task_summary[task.task_name]['last_run'] = task.last_run

    # è®¡ç®—å¥åº·çŠ¶æ€
    for name, stats in task_summary.items():
        total = stats['success'] + stats['failed']
        stats['success_rate'] = (stats['success'] / total * 100) if total > 0 else 0

        # å¥åº·çŠ¶æ€åˆ¤æ–­
        if stats['success_rate'] >= 90:
            stats['health'] = 'healthy'
        elif stats['success_rate'] >= 70:
            stats['health'] = 'warning'
        else:
            stats['health'] = 'critical'

    return {
        "timestamp": datetime.now(),
        "tasks": task_summary
    }

@router.get("/crawler/logs")
async def get_crawler_logs(
    limit: int = 50,
    status: str = None,
    db = Depends(get_db)
):
    """è·å–çˆ¬è™«æ‰§è¡Œæ—¥å¿—"""
    query = db.query(CrawlerTaskLog).order_by(desc(CrawlerTaskLog.start_time))

    if status:
        query = query.filter(CrawlerTaskLog.status == status)

    logs = query.limit(limit).all()

    return {
        "logs": [
            {
                "id": log.id,
                "task_name": log.task_name,
                "status": log.status,
                "start_time": log.start_time,
                "duration": log.duration_seconds,
                "records": log.records_count,
                "error": log.error_message,
                "retry_count": log.retry_count
            }
            for log in logs
        ]
    }
```

### 2. ç®€å•çš„ç›‘æ§å‰ç«¯
```html
<!-- admin/crawler_monitor.html -->
<!DOCTYPE html>
<html>
<head>
    <title>çˆ¬è™«ç›‘æ§</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css" />
</head>
<body>
    <div id="app">
        <h1>çˆ¬è™«å¥åº·ç›‘æ§</h1>

        <!-- å¥åº·çŠ¶æ€ -->
        <div v-for="(task, name) in health.tasks" :key="name">
            <h3>{{ name }}</h3>
            <p>çŠ¶æ€: <span :class="task.health">{{ task.health }}</span></p>
            <p>æˆåŠŸç‡: {{ task.success_rate.toFixed(1) }}%</p>
            <p>æœ€åè¿è¡Œ: {{ task.last_run }}</p>
        </div>

        <!-- æ‰§è¡Œæ—¥å¿— -->
        <h2>æœ€è¿‘æ‰§è¡Œæ—¥å¿—</h2>
        <table>
            <tr v-for="log in logs" :key="log.id">
                <td>{{ log.task_name }}</td>
                <td>{{ log.status }}</td>
                <td>{{ log.start_time }}</td>
                <td>{{ log.duration }}s</td>
                <td>{{ log.records }}æ¡</td>
            </tr>
        </table>
    </div>

    <script>
        const { createApp } = Vue;
        createApp({
            data() {
                return {
                    health: { tasks: {} },
                    logs: []
                }
            },
            mounted() {
                this.fetchHealth();
                this.fetchLogs();
                // æ¯30ç§’åˆ·æ–°
                setInterval(() => {
                    this.fetchHealth();
                    this.fetchLogs();
                }, 30000);
            },
            methods: {
                async fetchHealth() {
                    const res = await fetch('/api/v1/admin/crawler/health');
                    this.health = await res.json();
                },
                async fetchLogs() {
                    const res = await fetch('/api/v1/admin/crawler/logs');
                    const data = await res.json();
                    this.logs = data.logs;
                }
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>
```

## æµ‹è¯•æ¸…å•

### åŠŸèƒ½æµ‹è¯•
- [ ] æ­£å¸¸æ‰§è¡Œçˆ¬è™«ï¼Œè®°å½•æ—¥å¿—
- [ ] æ¨¡æ‹Ÿç½‘ç»œå¤±è´¥ï¼ŒéªŒè¯é‡è¯•
- [ ] éªŒè¯å¤±è´¥åå‘é€é’‰é’‰é€šçŸ¥
- [ ] éªŒè¯æˆåŠŸç‡ç»Ÿè®¡æ­£ç¡®
- [ ] éªŒè¯ç›‘æ§é¢æ¿æ˜¾ç¤ºæ­£å¸¸

### å‹åŠ›æµ‹è¯•
- [ ] 6ä¸ªçˆ¬è™«åŒæ—¶è¿è¡Œï¼Œæ— å†²çª
- [ ] è¿ç»­å¤±è´¥3æ¬¡ååœæ­¢é‡è¯•
- [ ] æ•°æ®åº“å¹¶å‘å†™å…¥æ— é”

### å‘Šè­¦æµ‹è¯•
- [ ] å¤±è´¥å‘Šè­¦èƒ½æ”¶åˆ°
- [ ] æ¯æ—¥æŠ¥å‘Šå®šæ—¶å‘é€
- [ ] @æ‰€æœ‰äººåŠŸèƒ½æ­£å¸¸
